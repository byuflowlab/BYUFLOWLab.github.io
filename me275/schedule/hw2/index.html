<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en-us">

  <head>
  <link href="https://gmpg.org/xfn/11" rel="profile">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta http-equiv="content-type" content="text/html; charset=utf-8">

  <!-- Enable responsiveness on mobile devices-->
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">

  <title>
    
      HW 2 &middot; ME 275
    
  </title>

  <!-- CSS -->
  <link rel="stylesheet" href="/public/css/poole.css">
  <link rel="stylesheet" href="/public/css/syntax.css">
  <link rel="stylesheet" href="/public/css/hyde.css">
  <link rel="stylesheet" href="/public/css/my.css">
  <link rel="stylesheet" href="/public/css/academicons.css">
  <link rel="stylesheet" type="text/css" media="screen" href="/public/css/toc.css">
  <link href="//maxcdn.bootstrapcdn.com/font-awesome/4.2.0/css/font-awesome.min.css" rel="stylesheet">

  <!-- Icons -->
  <!-- <link rel="apple-touch-icon-precomposed" sizes="144x144" href="/public/apple-touch-icon-144-precomposed.png"> -->
  <link rel="shortcut icon" href="/public/favicon.ico">
  <link rel="apple-touch-icon-precomposed" sizes="57x57" href="/public/apple-touch-icon-57x57.png" />
  <link rel="apple-touch-icon-precomposed" sizes="114x114" href="/public/apple-touch-icon-114x114.png" />
  <link rel="apple-touch-icon-precomposed" sizes="72x72" href="/public/apple-touch-icon-72x72.png" />
  <link rel="apple-touch-icon-precomposed" sizes="144x144" href="/public/apple-touch-icon-144x144.png" />
  <link rel="apple-touch-icon-precomposed" sizes="60x60" href="/public/apple-touch-icon-60x60.png" />
  <link rel="apple-touch-icon-precomposed" sizes="120x120" href="/public/apple-touch-icon-120x120.png" />
  <link rel="apple-touch-icon-precomposed" sizes="76x76" href="/public/apple-touch-icon-76x76.png" />
  <link rel="apple-touch-icon-precomposed" sizes="152x152" href="/public/apple-touch-icon-152x152.png" />

  <!-- RSS -->
  <link rel="alternate" type="application/rss+xml" title="RSS" href="/atom.xml">

  <!-- script -->
  <script type="text/javascript">  // used to hide/show BibTeX blocks
  <!--
      function toggle_visibility(id) {
         var e = document.getElementById(id);
         if(e.style.display == 'block')
            e.style.display = 'none';
         else
            e.style.display = 'block';
      }
  //-->
  </script>

  <!-- mathjax -->
  <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript">
  </script>


</head>


  <body class="theme-base-08 layout-top">

    <div class="sidebar">
  <div class="container">
    <div class="sidebar-about">
      <h1>
        <a href="/me275">
          ME 275
        </a>
      </h1>
      <p class="lead">Computaitional Methods</p>
    </div>

    <nav class="sidebar-nav">

      <a class="sidebar-nav-item" href="/me275/syllabus">Syllabus</a>
      <a class="sidebar-nav-item" href="/me275/schedule">Schedule</a>
      <a class="sidebar-nav-item" href="/me275/resources">Resources</a>

    </nav>

    <p>&copy; 2024. All rights reserved.</p>
  </div>
</div>


    <div class="content container">
    <!-- <h1 class="page-title">HW 2</h1> -->
      <h1 id="hw-2">HW 2</h1>

<p>due 9/19/2024 before midnight via Learning Suite
<span style="float:right;">25 possible points</span></p>

<hr />

<ol>
  <li>
    <p><em>Roundoff error</em> occurs because numbers must be represented with limited precision on a computer.
 Write a function to compute the following quantity for an integer input \(n\) (use a for loop rather than a built-in sum function, built-in functions usually do smart things like pairwise summation to reduce/eliminate this issue):</p>

\[f(n) = \left| \frac{n}{10} - \sum_{i = 1}^n 0.1 \right|\]

    <p>Mathematically the result should be zero, but with finite precision arithmetic it will not be zero because of roundoff error (and the error will get worse as \(n\) increases).</p>

    <p>Write a loop that computes the absolute error for \(n = 10, 100, 1000, \dots, 1000000\).
 Plot the roundoff error with \(n\) on the x-axis and roundoff error on the y-axis.  When data spans multiple orders of magnitude, as it does in this case, a log scale is usually preferable.  (see <code class="language-plaintext highlighter-rouge">pyplot.loglog</code>).  Always labels your axes!</p>
  </li>
  <li>
    <p><em>Truncation Error</em>.  One method to calculate \(\pi\) is the Leibniz formula:</p>

\[\pi = 4 \sum_{k = 0}^\infty \frac{(-1)^k}{2k + 1}\]

    <p>Because we cannot use an infinite number of terms, the resulting error is called truncation error (note that this is different than roundoff error as it would still exist even if we were able to use exact precision numbers with no rounding).  Create a Python script that uses a loop to estimate \(\pi\) using the above formula for \(n = 0, 1, 2, \ldots, 20\) terms.  For each value of \(n\), compute the relative percent error.  Plot the truncation percent error on the y-axis.</p>
  </li>
  <li>
    <p>The equations for projectile motion in two-dimensions (neglecting air resistance) are:</p>

\[s_x = V\cos(\theta) t\\
 s_y = V\sin(\theta) t - \frac{g}{2}t^2\]

    <p>where \(s_x\) and \(s_y\) are the x and y position of the projectile (relative to your starting position), \(V\) is the magnitude of the initial velocity, \(t\) is time, and \(g\) is the acceleration of gravity.  Letâ€™s say you fire a projectile at 100 m/s and are aiming at a target 400 meters in \(x\) and 50 meters up in \(y\).  Determine the angle that you should fire the projectile at.  Hint: combine these equations into one equation by solving for \(t\) then plugging into the other, then you will have a one-dimensional residual function.</p>

    <p>Write your own bisection method to solve this.  A skeleton function is provided <a href="../bisection">here</a>.  Also solve this problem with scipy (see <code class="language-plaintext highlighter-rouge">scipy.optimize.root_scalar</code>) to check your answer.  Note that there are two possible answers (a low angle and a high angle).  You should report the low angle.</p>
  </li>
</ol>

<!-- 1. Iterative algorithms are extremely common in engineering problems.  We'll first try a basic iterative algorithm, for which you know the answer, so that you can easily check your answers.  The following algorithm is an old way to compute the square root of any positive number $$x$$:

$$
s_{i+1} = \frac{1}{2}\left(s_i + \frac{x}{s_i} \right)
$$

The value $$s_i$$ is the current estimate for the square root of $$x$$ and $$s_{i+1}$$ is an updated estimate (from which we can repeat the process again and again).  Side note: this method where we update the new estimate from an explicit function of the current estimate ($$s_{i+1} = f(s_i)$$) is called *fixed-point iteration*.

To implement this algorithm, it is perhaps easiest to start with a for loop for some fixed number of iterations.  We won't know how many iterations are needed to converge beforehand, but we can experiment.  If that seems to be working well, then replace the for loop with a better version: a while loop that stops once the relative error drops below $$10^{-6}$$.  In computing the relative error we don't actually know the exact answer to compare to, which is a common scenario, so we use the new estimate as the "true answer" and compare to the prior value. -->

    </div>

  </body>
</html>
